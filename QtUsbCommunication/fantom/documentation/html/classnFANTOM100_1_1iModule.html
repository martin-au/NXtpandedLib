<html><body>

<!-- Generated by Doxygen 1.2.11.1 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; </center>
<hr><h1>nFANTOM100::iModule  Class Reference</h1>Interface to a firmware module on a LEGO MINDSTORMS NXT. 
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="iModule_8h-source.html">iModule.h</a>&gt;</code>
<p>
<a href="classnFANTOM100_1_1iModule-members.html">List of all members.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td colspan=2><br><h2>Public Methods</h2></td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classnFANTOM100_1_1iModule.html#a0">getName</a> (ViChar moduleName[]) const=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Retrieves the name of this module.</em> <a href="#a0">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual ViUInt32&nbsp;</td><td valign=bottom><a class="el" href="classnFANTOM100_1_1iModule.html#a1">getModuleID</a> (void) const=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Retrieves the internal module ID of this module.</em> <a href="#a1">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual ViUInt32&nbsp;</td><td valign=bottom><a class="el" href="classnFANTOM100_1_1iModule.html#a2">getModuleSize</a> (void) const=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Retrieves the size in bytes of this module.</em> <a href="#a2">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual ViUInt32&nbsp;</td><td valign=bottom><a class="el" href="classnFANTOM100_1_1iModule.html#a3">getModuleIOMapSize</a> (void) const=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Retrieves the size in bytes of the I/O map associated with this module.</em> <a href="#a3">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual ViUInt32&nbsp;</td><td valign=bottom><a class="el" href="classnFANTOM100_1_1iModule.html#a4">readIOMap</a> (ViUInt32 offsetInBytes, ViUInt32 numberOfBytes, ViPBuf dataBufferPtr, <a class="el" href="classnFANTOM100_1_1tStatus.html">tStatus</a> &amp;status)=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Reads a portion of this module's I/O map.</em> <a href="#a4">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual ViUInt32&nbsp;</td><td valign=bottom><a class="el" href="classnFANTOM100_1_1iModule.html#a5">writeIOMap</a> (ViUInt32 offsetInBytes, ViUInt32 numberOfBytes, const ViByte dataBufferPtr[], <a class="el" href="classnFANTOM100_1_1tStatus.html">tStatus</a> &amp;status)=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Writes a portion of this module's I/O map.</em> <a href="#a5">More...</a><em></em></font><br><br></td></tr>
<tr><td colspan=2><br><h2>Protected Methods</h2></td></tr>
<tr><td nowrap align=right valign=top><a name="b0" doxytag="nFANTOM100::iModule::~iModule"></a>
virtual&nbsp;</td><td valign=bottom><a class="el" href="classnFANTOM100_1_1iModule.html#b0">~iModule</a> ()=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Destructor.</em></font><br><br></td></tr>
<tr><td colspan=2><br><h2>Friends</h2></td></tr>
<tr><td nowrap align=right valign=top><a name="l0" doxytag="nFANTOM100::iModule::tNXT"></a>
class&nbsp;</td><td valign=bottom><b>tNXT</b></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Interface to a firmware module on a LEGO MINDSTORMS NXT.
<p>
<hr><h2>Member Function Documentation</h2>
<a name="a1" doxytag="nFANTOM100::iModule::getModuleID"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual ViUInt32 nFANTOM100::iModule::getModuleID </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the internal module ID of this module.
<p>
<dl compact><dt><b>
Returns: </b><dd>
The internal module ID of this module. </dl>    </td>
  </tr>
</table>
<a name="a3" doxytag="nFANTOM100::iModule::getModuleIOMapSize"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual ViUInt32 nFANTOM100::iModule::getModuleIOMapSize </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the size in bytes of the I/O map associated with this module.
<p>
<dl compact><dt><b>
Returns: </b><dd>
The size in bytes of the I/O map associated with this module. </dl>    </td>
  </tr>
</table>
<a name="a2" doxytag="nFANTOM100::iModule::getModuleSize"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual ViUInt32 nFANTOM100::iModule::getModuleSize </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the size in bytes of this module.
<p>
<dl compact><dt><b>
Returns: </b><dd>
The size in bytes of this module. </dl>    </td>
  </tr>
</table>
<a name="a0" doxytag="nFANTOM100::iModule::getName"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void nFANTOM100::iModule::getName </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ViChar&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>moduleName</em>[]          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the name of this module.
<p>
<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>moduleName</em>&nbsp;</td><td>
Populated with the name of this module. The module name character array must be able to accomodate a NULL-terminated, 15.3 formatted module name. That is, it must have a capacity of 20 bytes. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a4" doxytag="nFANTOM100::iModule::readIOMap"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual ViUInt32 nFANTOM100::iModule::readIOMap </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ViUInt32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>offsetInBytes</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>ViUInt32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>numberOfBytes</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>ViPBuf&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>dataBufferPtr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classnFANTOM100_1_1tStatus.html">tStatus</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>status</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Reads a portion of this module's I/O map.
<p>
Reads the data located at [I/O map address] + [specified offset in bytes] into the specified data buffer. The read will attempt to copy the specified number of bytes. No read occurs if the specified status is fatal. The ownership of data buffer is not transferred to this module object.<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>offsetInBytes</em>&nbsp;</td><td>
The index of the byte in the I/O map at which to start the read. </td></tr>
<tr><td valign=top><em>numberOfBytes</em>&nbsp;</td><td>
The number of bytes that should be read from the I/O map. </td></tr>
<tr><td valign=top><em>dataBufferPtr</em>&nbsp;</td><td>
A pointer to the data buffer that will be populated with the data that is read. The capacity of the specified data buffer must be at least the specified number of bytes. </td></tr>
<tr><td valign=top><em>status</em>&nbsp;</td><td>
Status chaining object. </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
The number of bytes actually read from the I/O map.</dl><dl compact><dt><b>
Postcondition: </b><dd>
The specified data buffer may be deallocated. </dl>    </td>
  </tr>
</table>
<a name="a5" doxytag="nFANTOM100::iModule::writeIOMap"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual ViUInt32 nFANTOM100::iModule::writeIOMap </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ViUInt32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>offsetInBytes</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>ViUInt32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>numberOfBytes</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const ViByte&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>dataBufferPtr</em>[], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classnFANTOM100_1_1tStatus.html">tStatus</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>status</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Writes a portion of this module's I/O map.
<p>
Writes the specified data into this module's I/O map. The write starts at [I/O map address] + [specified offset in bytes] and stops after the specified number of bytes have been written. No write occurs if the specified status is fatal. The ownership of data buffer is not transferred to this module object.<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>offsetInBytes</em>&nbsp;</td><td>
The index of the byte in the I/O map at which to start the write. </td></tr>
<tr><td valign=top><em>numberOfBytes</em>&nbsp;</td><td>
The number of bytes to write into the I/O map. </td></tr>
<tr><td valign=top><em>dataBufferPtr</em>&nbsp;</td><td>
A pointer to the data buffer that contains the data that will be written. The capacity of the specified data buffer must be at least the specified number of bytes. </td></tr>
<tr><td valign=top><em>status</em>&nbsp;</td><td>
Status chaining object. </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
The number of bytes actually written into the I/O map.</dl><dl compact><dt><b>
Postcondition: </b><dd>
The specified data buffer may be deallocated. </dl>    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="iModule_8h-source.html">iModule.h</a></ul>
<p>
   &copy; Copyright 2005-2006, National Instruments Corporation.  All rights reserved.
</p>
</body></html>

